{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10460\viewh15240\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 import React, \{ useEffect, useRef, useState \} from "react";\
import \{ Card, CardContent, CardHeader, CardTitle \} from "@/components/ui/card";\
import \{ Button \} from "@/components/ui/button";\
import \{ Slider \} from "@/components/ui/slider";\
import \{ Select, SelectContent, SelectItem, SelectTrigger, SelectValue \} from "@/components/ui/select";\
import \{ Switch \} from "@/components/ui/switch";\
import \{ Input \} from "@/components/ui/input";\
import \{ Label \} from "@/components/ui/label";\
import \{ ResponsiveContainer, LineChart, Line, CartesianGrid, XAxis, YAxis, Tooltip, AreaChart, Area, Label as ChartLabel \} from "recharts";\
import \{ Play, Pause, RotateCcw, Eraser, Wand2, MousePointer2, Brain \} from "lucide-react";\
import \{ motion \} from "framer-motion";\
\
const ACTIONS = ["up", "right", "down", "left"] as const;\
type Action = typeof ACTIONS[number];\
\
type CellType = "empty" | "wall" | "goal" | "lava" | "start";\
\
type PointTR = \{ t: number; R: number \};\
type PointTC = \{ t: number; C: number \};\
type PointEG = \{ ep: number; G: number \};\
\
const clamp = (v: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, v));\
\
function psColor01(x: number) \{\
  const v = clamp(x, 0, 1);\
  const b = 200 + Math.round(55 * v);\
  const g = 200 + Math.round(30 * v);\
  const r = 220 - Math.round(80 * v);\
  return `rgb($\{r\},$\{g\},$\{b\})`;\
\}\
\
function makeGrid(w: number, h: number, preset: string): CellType[][] \{\
  const grid: CellType[][] = Array.from(\{ length: h \}, () => Array.from(\{ length: w \}, () => "empty" as CellType));\
  if (preset === "open") \{\
    grid[0][w - 1] = "goal";\
    grid[h - 1][0] = "start";\
    grid[h - 1][w - 2] = "lava";\
  \} else if (preset === "corridor") \{\
    for (let y = 1; y < h - 1; y++) for (let x = 1; x < w - 1; x++) grid[y][x] = y === Math.floor(h / 2) ? "empty" : "wall";\
    grid[h - 1][0] = "start";\
    grid[Math.floor(h / 2)][w - 1] = "goal";\
  \} else if (preset === "two-rooms") \{\
    const doorY = Math.floor(h / 2);\
    for (let y = 0; y < h; y++) \{\
      if (y === doorY) continue;\
      const mid = Math.floor(w / 2);\
      grid[y][mid] = "wall";\
    \}\
    grid[h - 1][1] = "start";\
    grid[0][w - 2] = "goal";\
    grid[h - 2][2] = "lava";\
  \} else if (preset === "maze") \{\
    for (let y = 1; y < h - 1; y += 2) \{\
      for (let x = 1; x < w - 1; x++) grid[y][x] = "wall";\
      const gap = 1 + ((y * 3) % (w - 2));\
      grid[y][gap] = "empty";\
    \}\
    grid[h - 1][0] = "start";\
    grid[0][w - 1] = "goal";\
  \}\
  return grid;\
\}\
\
class PSLayer \{\
  w:number; h:number; hvals: Float32Array; gvals: Float32Array;\
  constructor(w:number,h:number)\{\
    this.w=w; this.h=h; this.hvals = new Float32Array(w*h*4).fill(1);\
    this.gvals = new Float32Array(w*h*4);\
  \}\
  idx(x:number,y:number,a:number)\{ return ((y*this.w)+x)*4 + a; \}\
  getH(x:number,y:number,a:number)\{ return this.hvals[this.idx(x,y,a)]; \}\
  getG(x:number,y:number,a:number)\{ return this.gvals[this.idx(x,y,a)]; \}\
  decayGlow(eta:number)\{ for (let i=0;i<this.gvals.length;i++) this.gvals[i]*=(1-eta); \}\
  addGlow(x:number,y:number,a:number,amount:number)\{ this.gvals[this.idx(x,y,a)]+=amount; \}\
  rewardUpdate(r:number,lambda:number,kappa:number)\{\
    for (let i=0;i<this.hvals.length;i++)\{\
      const h=this.hvals[i]; const g=this.gvals[i];\
      const delta=lambda*(g*r - kappa*(h-1));\
      this.hvals[i]=h+delta;\
    \}\
  \}\
  normalize()\{\
    for (let i=0;i<this.hvals.length;i++) this.hvals[i]=Math.max(0.1,Math.min(10,this.hvals[i]));\
    for (let i=0;i<this.gvals.length;i++) this.gvals[i]=Math.max(0,Math.min(5,this.gvals[i]));\
  \}\
\}\
\
function stepXY(x:number,y:number,a:Action)\{\
  if(a==="up")return\{x,y:y-1\};\
  if(a==="down")return\{x,y:y+1\};\
  if(a==="left")return\{x:x-1,y\};\
  return\{x:x+1,y\};\
\}\
\
function SliderWithVal(\{ label, min, max, step=1, value, onChange \}: \{ label: string, min: number, max: number, step?: number, value: number, onChange: (v:number)=>void \})\{\
  return (\
    <div>\
      <div className="flex items-center justify-between mb-1"><Label>\{label\}</Label><span className="text-xs text-neutral-600">\{typeof value==="number"? value.toFixed(2): value\}</span></div>\
      <Slider min=\{min\} max=\{max\} step=\{step\} value=\{[value as number]\} onValueChange=\{(v)=>onChange(v[0])\} />\
    </div>\
  );\
\}\
\
function PSInspector(\{ gridW, gridH, grid, ps, cellSize \}:\{ gridW:number, gridH:number, grid: CellType[][], ps: PSLayer, cellSize:number \})\{\
  const [hover, setHover] = useState<\{x:number,y:number\}|null>(null);\
  return (\
    <div className="overflow-auto">\
      <div className="inline-block border rounded-xl">\
        \{Array.from(\{ length: gridH \}).map((_, y) => (\
          <div key=\{`pi-$\{y\}`\} className="flex">\
            \{Array.from(\{ length: gridW \}).map((__, x) => \{\
              const isWall = grid[y][x]==="wall";\
              let hAvg = 0; for (let a=0;a<4;a++) hAvg += ps.getH(x,y,a); hAvg/=4;\
              const hNorm = clamp((hAvg-1)/(3-1), 0, 1);\
              const bg = isWall ? "#222" : psColor01(hNorm);\
              let glow = 0; for (let a=0;a<4;a++) glow = Math.max(glow, ps.getG(x,y,a));\
              const ringOpacity = clamp(glow/2, 0, 0.9);\
              return (\
                <div key=\{`pi-$\{x\}-$\{y\}`\} onMouseEnter=\{()=>setHover(\{x,y\})\} onMouseLeave=\{()=>setHover(null)\} className="relative border border-neutral-300 flex items-center justify-center" style=\{\{ width: cellSize, height: cellSize, background: bg \}\}>\
                  \{!isWall && (\
                    <>\
                      <div className="absolute inset-0 text-[10px] leading-tight flex flex-col items-center justify-center text-black">\
                        <div>\uc0\u8593  \{ps.getH(x,y,0).toFixed(2)\}</div>\
                        <div className="flex justify-between w-full px-1">\
                          <span>\uc0\u8592  \{ps.getH(x,y,3).toFixed(2)\}</span>\
                          <span>\{ps.getH(x,y,1).toFixed(2)\} \uc0\u8594 </span>\
                        </div>\
                        <div>\uc0\u8595  \{ps.getH(x,y,2).toFixed(2)\}</div>\
                      </div>\
                      <div className="absolute inset-0 rounded-md" style=\{\{ boxShadow: `0 0 0 3px rgba(59,130,246,$\{ringOpacity\}) inset` \}\} />\
                    </>\
                  )\}\
                  \{grid[y][x]==="goal" && <span className="absolute inset-0 flex items-center justify-center text-xs font-bold">\uc0\u55356 \u57281 </span>\}\
                  \{grid[y][x]==="lava" && <span className="absolute inset-0 flex items-center justify-center text-xs font-bold">\uc0\u55357 \u56613 </span>\}\
                  \{grid[y][x]==="start" && <span className="absolute inset-0 flex items-center justify-center text-xs font-bold">\uc0\u55357 \u57314 </span>\}\
                </div>\
              );\
            \})\}\
          </div>\
        ))\}\
      </div>\
      \{hover && (\
        <div className="mt-2 text-xs text-neutral-700">PS cell (\{hover.x\},\{hover.y\})</div>\
      )\}\
    </div>\
  );\
\}\
\
function RewardsPanel(\{ rewardTrace, cumTrace, episodeReturns \}: \{ rewardTrace: PointTR[]; cumTrace: PointTC[]; episodeReturns: PointEG[]; \}) \{\
  return (\
    <Card className="rounded-xl">\
      <CardHeader><CardTitle className="text-lg">Rewards</CardTitle></CardHeader>\
      <CardContent className="space-y-6">\
        <div className="h-64 mb-12">\
          <ResponsiveContainer width="100%" height="100%">\
            <LineChart data=\{rewardTrace\}>\
              <CartesianGrid strokeDasharray="3 3" />\
              <XAxis dataKey="t" tickMargin=\{14\}><ChartLabel value="Time steps" offset=\{-5\} position="insideBottom"/></XAxis>\
              <YAxis width=\{56\}></YAxis>\
              <Tooltip formatter=\{(v:any)=>Number(v).toFixed(2)\} labelFormatter=\{(l)=>`t=$\{l\}`\}/>\
              <Line type="monotone" dataKey="R" strokeWidth=\{2\} dot=\{false\}/>\
              <ChartLabel value="Instant reward over time" position="top" offset=\{10\}/>\
            </LineChart>\
          </ResponsiveContainer>\
        </div>\
        <div className="h-64 mb-12">\
          <ResponsiveContainer width="100%" height="100%">\
            <AreaChart data=\{cumTrace\}>\
              <CartesianGrid strokeDasharray="3 3" />\
              <XAxis dataKey="t" tickMargin=\{14\}><ChartLabel value="Time steps" offset=\{-5\} position="insideBottom"/></XAxis>\
              <YAxis width=\{56\}></YAxis>\
              <Tooltip formatter=\{(v:any)=>Number(v).toFixed(2)\} labelFormatter=\{(l)=>`t=$\{l\}`\}/>\
              <Area type="monotone" dataKey="C" strokeWidth=\{2\} fillOpacity=\{0.2\} />\
              <ChartLabel value="Cumulative reward over time" position="top" offset=\{10\}/>\
            </AreaChart>\
          </ResponsiveContainer>\
        </div>\
        <div className="h-64">\
          <ResponsiveContainer width="100%" height="100%">\
            <LineChart data=\{episodeReturns\}>\
              <CartesianGrid strokeDasharray="3 3" />\
              <XAxis dataKey="ep" tickMargin=\{14\}><ChartLabel value="Episode" offset=\{-5\} position="insideBottom"/></XAxis>\
              <YAxis width=\{56\}></YAxis>\
              <Tooltip formatter=\{(v:any)=>Number(v).toFixed(2)\} labelFormatter=\{(l)=>`ep=$\{l\}`\}/>\
              <Line type="monotone" dataKey="G" strokeWidth=\{2\} dot />\
              <ChartLabel value="Episode return per episode" position="top" offset=\{10\}/>\
            </LineChart>\
          </ResponsiveContainer>\
        </div>\
      </CardContent>\
    </Card>\
  );\
\}\
\
export default function InteractiveRLLab()\{\
  const [gridW,setGridW]=useState(6);\
  const [gridH,setGridH]=useState(6);\
  const [preset,setPreset]=useState("open");\
  const [grid,setGrid]=useState<CellType[][]>(()=>makeGrid(6,6,"open"));\
  const [startPos,setStartPos]=useState<\{x:number,y:number\}>(()=>(\{x:0,y:5\}));\
  const [agent,setAgent]=useState<\{x:number,y:number\}>(\{x:startPos.x,y:startPos.y\});\
  const [episode,setEpisode]=useState(1);\
  const [running,setRunning]=useState(true);\
  const [speed,setSpeed]=useState(12);\
  const [stepCost,setStepCost]=useState(-0.01);\
  const [goalReward,setGoalReward]=useState(1);\
  const [lavaPenalty,setLavaPenalty]=useState(-1);\
  const [wind,setWind]=useState(false);\
  const [psLambda,setPsLambda]=useState(0.2);\
  const [psKappa,setPsKappa]=useState(0.05);\
  const [psGlowEta,setPsGlowEta]=useState(0.05);\
  const [epsilon,setEpsilon]=useState(0.1);\
  const [tau,setTau]=useState(1);\
  const [rewardTrace,setRewardTrace]=useState<PointTR[]>([]);\
  const [cumTrace,setCumTrace]=useState<PointTC[]>([]);\
  const [episodeReturns,setEpisodeReturns]=useState<PointEG[]>([]);\
  const [currentEpReturn,setCurrentEpReturn]=useState(0);\
  const tRef=useRef(0);\
  const totalReturnRef=useRef(0);\
  const currentEpReturnRef=useRef(0);\
  const psRef=useRef<PSLayer>(new PSLayer(gridW,gridH));\
  const gridRef=useRef(grid); useEffect(()=>\{gridRef.current=grid\},[grid]);\
  const agentRef=useRef(agent); useEffect(()=>\{agentRef.current=agent\},[agent]);\
  const startPosRef=useRef(startPos); useEffect(()=>\{startPosRef.current=startPos\},[startPos]);\
  const windRef=useRef(wind); useEffect(()=>\{windRef.current=wind\},[wind]);\
  const psLambdaRef=useRef(psLambda); useEffect(()=>\{psLambdaRef.current=psLambda\},[psLambda]);\
  const psKappaRef=useRef(psKappa); useEffect(()=>\{psKappaRef.current=psKappa\},[psKappa]);\
  const psGlowEtaRef=useRef(psGlowEta); useEffect(()=>\{psGlowEtaRef.current=psGlowEta\},[psGlowEta]);\
  const epsilonRef=useRef(epsilon); useEffect(()=>\{epsilonRef.current=epsilon\},[epsilon]);\
  const tauRef=useRef(tau); useEffect(()=>\{tauRef.current=tau\},[tau]);\
  const stepCostRef=useRef(stepCost); useEffect(()=>\{stepCostRef.current=stepCost\},[stepCost]);\
  const goalRewardRef=useRef(goalReward); useEffect(()=>\{goalRewardRef.current=goalReward\},[goalReward]);\
  const lavaPenaltyRef=useRef(lavaPenalty); useEffect(()=>\{lavaPenaltyRef.current=lavaPenalty\},[lavaPenalty]);\
\
  useEffect(()=>\{psRef.current=new PSLayer(gridW,gridH);\},[gridW,gridH]);\
\
  useEffect(()=>\{\
    const g=makeGrid(gridW,gridH,preset);\
    setGrid(g);\
    const sp=\{x:0,y:gridH-1\};\
    setStartPos(sp);\
    setAgent(sp);\
    setEpisode(1);\
    setRewardTrace([]);\
    setCumTrace([]);\
    setEpisodeReturns([]);\
    setCurrentEpReturn(0);\
    tRef.current=0; totalReturnRef.current=0; currentEpReturnRef.current=0;\
  \},[gridW,gridH,preset]);\
\
  useEffect(()=>\{\
    if(!running) return;\
    const interval=setInterval(()=>\{tick();\},Math.max(20,1000/Math.max(1,speed)));\
    return()=>clearInterval(interval);\
  \},[running,speed]);\
\
  function envReward(x:number,y:number)\{\
    const c=gridRef.current[y]?.[x];\
    if(c==="goal")return goalRewardRef.current;\
    if(c==="lava")return lavaPenaltyRef.current;\
    if(c==="wall")return -0.2;\
    return stepCostRef.current;\
  \}\
\
  function isTerminal(x:number,y:number)\{\
    const c=gridRef.current[y]?.[x];\
    return c==="goal"||c==="lava";\
  \}\
\
  function legal(x:number,y:number)\{\
    return x>=0&&y>=0&&x<gridW&&y<gridH&&gridRef.current[y][x]!=="wall";\
  \}\
\
  function windJitter(a:number)\{\
    if(!windRef.current) return a;\
    const r=Math.random();\
    if(r<0.1) return (a+1)%4;\
    if(r<0.2) return (a+3)%4;\
    return a;\
  \}\
\
  function pickAction(x:number,y:number)\{\
    if (Math.random() < epsilonRef.current) return Math.floor(Math.random()*4);\
    let hs:number[] = new Array(4).fill(0);\
    for (let a=0;a<4;a++) hs[a]=psRef.current.getH(x,y,a);\
    const t=Math.max(0.01, tauRef.current);\
    const maxH=Math.max(...hs);\
    const exps=hs.map(h=>Math.exp((h-maxH)/t));\
    const sum=exps.reduce((a,b)=>a+b,0);\
    let r=Math.random(); let acc=0;\
    for(let a=0;a<4;a++)\{acc+=exps[a]/sum; if(r<=acc)return a;\}\
    return 0;\
  \}\
\
  function attemptMove(x:number,y:number,a:number)\{\
    const next=stepXY(x,y,ACTIONS[windJitter(a)]);\
    if(!legal(next.x,next.y))return\{x,y\};\
    return next;\
  \}\
\
  function restartEpisode(lastReward:number)\{\
    const G=currentEpReturnRef.current+lastReward;\
    setEpisodeReturns(l=>[...l,\{ep:episode,G\}]);\
    setEpisode(e=>e+1);\
    setCurrentEpReturn(0);\
    currentEpReturnRef.current=0;\
    setAgent(startPosRef.current);\
    agentRef.current=startPosRef.current;\
  \}\
\
  function tick()\{\
    const \{x,y\}=agentRef.current;\
    const a=pickAction(x,y);\
    psRef.current.decayGlow(psGlowEtaRef.current);\
    psRef.current.addGlow(x,y,a,1);\
    const s1=attemptMove(x,y,a);\
    const r=envReward(s1.x,s1.y);\
    psRef.current.rewardUpdate(r,psLambdaRef.current,psKappaRef.current);\
    psRef.current.normalize();\
    tRef.current+=1;\
    totalReturnRef.current+=r;\
    setRewardTrace(tr=>\{const nxt=[...tr,\{t:tRef.current,R:r\}]; return nxt.length>1000?nxt.slice(-1000):nxt;\});\
    setCumTrace(ct=>\{const nxt=[...ct,\{t:tRef.current,C:totalReturnRef.current\}]; return nxt.length>1000?nxt.slice(-1000):nxt;\});\
    setCurrentEpReturn(v=>v+r);\
    setAgent(s1);\
    agentRef.current=s1;\
    if(isTerminal(s1.x,s1.y)) restartEpisode(r);\
  \}\
\
  const cellSize=36;\
  const [inspectorSize,setInspectorSize]=useState(54);\
  const canvasW=gridW*cellSize;\
  const canvasH=gridH*cellSize;\
  const [tool,setTool]=useState<"draw"|"pick"|"erase">("draw");\
  const [brush,setBrush]=useState<CellType>("wall");\
\
  function onCellClick(x:number,y:number)\{\
    if(tool==="pick")\{ setBrush(gridRef.current[y][x]); return; \}\
    const b = tool==="erase"?"empty":brush;\
    const g = gridRef.current.map(row=>[...row]);\
    g[y][x]=b;\
    setGrid(g);\
    if(b==="start")\{ setStartPos(\{x,y\}); setAgent(\{x,y\}); agentRef.current=\{x,y\}; \}\
  \}\
\
  return (\
    <div className="w-full min-h-screen p-4 md:p-6 bg-neutral-100">\
      <div className="max-w-7xl mx-auto grid grid-cols-1 xl:grid-cols-3 gap-4">\
        <Card className="xl:col-span-2 shadow-xl rounded-2xl">\
          <CardHeader className="flex items-center justify-between">\
            <CardTitle className="text-2xl">Projective Simulation RL Lab</CardTitle>\
            <div className="flex items-center gap-2">\
              <Button variant=\{running?"secondary":"default"\} onClick=\{()=>setRunning(r=>!r)\}>\{running?(<><Pause className="w-4 h-4 mr-1"/>Pause</>):(<><Play className="w-4 h-4 mr-1"/>Run</>)\}</Button>\
              <Button variant="outline" onClick=\{()=>\{ setAgent(startPosRef.current); agentRef.current=startPosRef.current; setEpisode(1); setRewardTrace([]); setCumTrace([]); setEpisodeReturns([]); setCurrentEpReturn(0); tRef.current=0; totalReturnRef.current=0; currentEpReturnRef.current=0; \}\}><RotateCcw className="w-4 h-4 mr-1"/>Reset Agent</Button>\
            </div>\
          </CardHeader>\
          <CardContent>\
            <div className="grid md:grid-cols-[auto,300px] gap-4">\
              <div className="overflow-auto">\
                <div className="relative select-none" style=\{\{ width: canvasW, height: canvasH \}\}>\
                  \{Array.from(\{ length: gridH \}).map((_, y) => (\
                    <div key=\{y\} className="flex">\
                      \{Array.from(\{ length: gridW \}).map((__, x) => (\
                        <div\
                          key=\{`$\{x\}-$\{y\}`\}\
                          onMouseDown=\{(e) => \{ e.preventDefault(); onCellClick(x,y); \}\}\
                          onMouseEnter=\{(e)=>\{ if (e.buttons===1) onCellClick(x,y); \}\}\
                          className="border border-neutral-300 flex items-center justify-center"\
                          style=\{\{ width: cellSize, height: cellSize, background: cellBG(gridRef.current[y][x]) \}\}\
                          title=\{`($\{x\},$\{y\})`\}\
                        >\
                          \{agent.x===x && agent.y===y && (\
                            <motion.div layoutId="agent" className="w-6 h-6 rounded-full shadow" initial=\{false\} animate=\{\{ scale: 1 \}\} transition=\{\{ type: "spring", stiffness: 300, damping: 20 \}\} style=\{\{ background: "black" \}\} />\
                          )\}\
                        </div>\
                      ))\}\
                    </div>\
                  ))\}\
                </div>\
              </div>\
\
              <div className="space-y-4">\
                <Card className="rounded-xl">\
                  <CardHeader>\
                    <CardTitle className="text-lg">Environment</CardTitle>\
                  </CardHeader>\
                  <CardContent className="space-y-3">\
                    <Label className="text-sm">Preset</Label>\
                    <Select value=\{preset\} onValueChange=\{setPreset\}>\
                      <SelectTrigger><SelectValue /></SelectTrigger>\
                      <SelectContent>\
                        <SelectItem value="open">Open Field</SelectItem>\
                        <SelectItem value="corridor">Corridor</SelectItem>\
                        <SelectItem value="two-rooms">Two Rooms</SelectItem>\
                        <SelectItem value="maze">Maze</SelectItem>\
                      </SelectContent>\
                    </Select>\
\
                    <div className="grid grid-cols-2 gap-2 items-center">\
                      <div>\
                        <Label>Width</Label>\
                        <Input type="number" min=\{4\} max=\{30\} value=\{gridW\} onChange=\{e=>setGridW(clamp(parseInt(e.target.value||"6"),4,30))\}/>\
                      </div>\
                      <div>\
                        <Label>Height</Label>\
                        <Input type="number" min=\{4\} max=\{22\} value=\{gridH\} onChange=\{e=>setGridH(clamp(parseInt(e.target.value||"6"),4,22))\}/>\
                      </div>\
                    </div>\
\
                    <div className="grid grid-cols-3 gap-2">\
                      <Button variant=\{tool==="draw"?"default":"outline"\} onClick=\{()=>setTool("draw")\}><MousePointer2 className="w-4 h-4 mr-1"/>Draw</Button>\
                      <Button variant=\{tool==="pick"?"default":"outline"\} onClick=\{()=>setTool("pick")\}><Wand2 className="w-4 h-4 mr-1"/>Pick</Button>\
                      <Button variant=\{tool==="erase"?"default":"outline"\} onClick=\{()=>setTool("erase")\}><Eraser className="w-4 h-4 mr-1"/>Erase</Button>\
                    </div>\
\
                    <div className="grid grid-cols-5 gap-2 text-xs">\
                      \{(["wall","empty","goal","lava","start"] as CellType[]).map(c => (\
                        <button key=\{c\} onClick=\{()=>\{ setBrush(c); setTool("draw"); \}\} className=\{`rounded-md border p-2 $\{brush===c?"ring-2 ring-black":""\}`\} style=\{\{ background: cellBG(c) \}\}>\{c\}</button>\
                      ))\}\
                    </div>\
\
                    <div className="flex items-center justify-between">\
                      <Label>Wind/Stochasticity</Label>\
                      <Switch checked=\{wind\} onCheckedChange=\{setWind\} />\
                    </div>\
\
                    <SliderWithVal label="Steps/sec" min=\{1\} max=\{40\} step=\{1\} value=\{speed\} onChange=\{setSpeed\} />\
                    <SliderWithVal label="Step cost" min=\{-0.2\} max=\{0\} step=\{0.01\} value=\{stepCost\} onChange=\{setStepCost\} />\
                    <SliderWithVal label="Goal reward" min=\{0.1\} max=\{3\} step=\{0.1\} value=\{goalReward\} onChange=\{setGoalReward\} />\
                    <SliderWithVal label="Lava penalty" min=\{-3\} max=\{-0.1\} step=\{0.1\} value=\{lavaPenalty\} onChange=\{setLavaPenalty\} />\
                  </CardContent>\
                </Card>\
\
                <Card className="rounded-xl">\
                  <CardHeader>\
                    <CardTitle className="text-lg">PS Parameters</CardTitle>\
                  </CardHeader>\
                  <CardContent className="space-y-3">\
                    <SliderWithVal label="Reward coupling (\uc0\u955 )" min=\{0.01\} max=\{1\} step=\{0.01\} value=\{psLambda\} onChange=\{setPsLambda\}/>\
                    <SliderWithVal label="Damping (\uc0\u954 )" min=\{0\} max=\{0.5\} step=\{0.01\} value=\{psKappa\} onChange=\{setPsKappa\}/>\
                    <SliderWithVal label="Glow decay (\uc0\u951 )" min=\{0\} max=\{0.3\} step=\{0.005\} value=\{psGlowEta\} onChange=\{setPsGlowEta\}/>\
                    <SliderWithVal label="Exploration (\uc0\u949 )" min=\{0\} max=\{1\} step=\{0.01\} value=\{epsilon\} onChange=\{setEpsilon\}/>\
                    <SliderWithVal label="Softmax temperature (\uc0\u964 )" min=\{0.05\} max=\{5\} step=\{0.05\} value=\{tau\} onChange=\{setTau\}/>\
                    <div className="text-sm text-neutral-600">Episode: \{episode\} \'b7 Current G: \{fmt(currentEpReturn)\}</div>\
                    <div className="text-xs text-neutral-500">Total return: \{fmt(totalReturnRef.current)\}</div>\
                  </CardContent>\
                </Card>\
\
                <RewardsPanel rewardTrace=\{rewardTrace\} cumTrace=\{cumTrace\} episodeReturns=\{episodeReturns\} />\
              </div>\
            </div>\
          </CardContent>\
        </Card>\
\
        <Card className="shadow-xl rounded-2xl">\
          <CardHeader>\
            <CardTitle className="text-2xl flex items-center gap-2"><Brain className="w-5 h-5"/> PS Layer</CardTitle>\
          </CardHeader>\
          <CardContent>\
            <div className="space-y-4">\
              <div className="w-64"><SliderWithVal label="Inspector size" min=\{24\} max=\{72\} step=\{2\} value=\{inspectorSize\} onChange=\{setInspectorSize\} /></div>\
              <PSInspector gridW=\{gridW\} gridH=\{gridH\} grid=\{grid\} ps=\{psRef.current\} cellSize=\{inspectorSize\} />\
            </div>\
          </CardContent>\
        </Card>\
      </div>\
    </div>\
  );\
\}\
\
function fmt(v:number)\{\
  if (!Number.isFinite(v)) return "0.00";\
  return (Math.round(v * 100) / 100).toFixed(2);\
\}\
\
function cellBG(c: CellType)\{\
  switch (c)\{\
    case "wall": return "#cbd5e1";\
    case "goal": return "#a7f3d0";\
    case "lava": return "#fecaca";\
    case "start": return "#fde68a";\
    default: return "#ffffff";\
  \}\
\}\
}